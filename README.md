Developed by **Yron Lance Talban**  (April 2023)

<br>

# ARCANE ASCENT
A game about a lonely mage that decides to explore a cave. However, the mage forgot to learn any flight spells. It is up to you to help the mage exit the cave using quick movements to avoid getting impaled from spikes or fall to their demise.

Assembly game written for CSCB63 assignment. Uses [Mars MIPS Simulator](http://courses.missouristate.edu/kenvollmar/mars/)


<p align="center">
<a href="https://www.youtube.com/embed/4cxd8GXdnaY"> Watch the Demonstration Video here </a>
</p>

**Bitmap Display Configurations**
- Unit Width in Pixels: 4
- Unit Height in Pixels: 4
- Display Width in Pixels: 512
- Display Height in Pixels: 512
- Base Address for Display: 0x100080000 ($gp)



# Features and Techniques
- Basic platform movement mechanics 
    - MARS restrictions read a single key at a time, holding down a key is not read correctly. As such, I have provided some workarounds. To travel a far distance, you would need to repeatedly press the key in that direction.
    - Controls:
        - "a" goes left, "A" to go a smaller distance left.
        - "d" goes right, "D" to go a smaller distance right
        - "w" to jump/double jump (Also binded on "W" and "spacebar")
        - "q" to jump diagonally ("Q" has the same behaviour)
        - "e" to jump diagonally ("E" has the same behaviour)
        - "p" to restart (If in game, you lose a heart. It can also skip the gameover/winscreen delay)
- Ten unique levels to complete. Levels 1-4 designed to introduce the mechanics of the game.
    - The first level is designed to teach the player the objective of the game. "Grab key, go to gate."
    - The second level introduces the hazards of the game, that being spikes and falling out of the map along with the first pickup item.
    - The third level introduces the need for precision and introduces two more pickups. 
    - The fourth level introduces the gravity potion. While the level was designed to be completable without it, the gravity potion lessens the difficulty.
    - Since the player has been taught the mechanics, the remaining levels are challenges to test the players skill.

- Smooth frames.
    - Due to the rough movements of the game and fast reaction speeds required to avoid some predicaments, it was a top priority to ensure external variables such as choppy rendering rendering were not a cause of the players death.
- Semi-efficient Collision.
    - The game first applies vertical velocity and then horizontal velocity to the player. For each part, we pass the end position to what I call the "clamping function" prior to finalizing their positions. The "clamping function" checks for both platform collisions and entity collision (keys, potions, etc.)

    - While playing the game, there are several frames that would not require intensive checks for pickup collision. The "clamping function" mentioned above returns a player state which the game later uses to determine what path of operations to execute. As such, the game only scans for entity collisions when the "clamping function" passes an entity-collision flag.

    - For more information, refer to the video above.

# World Builder
The levels, win/lose/start screens were all generated by a world builder I had made specifically for this game. Since the world builder itself is a large enough project, I have dedicated a repository for it: https://github.com/isLenk/Arcane-Ascent-World-Builder
<br><br><br><br>

# Ideas not Implemented (Time Restriction)
To any future students who take this course, below are a couple of ideas (along with the solution) I had thought of implementing but was unable to due to the time restriction I had given myself. I deemed it a waste to simply forget these ideas and so I hope somebody might be inspired to implement this into their own projects.

I might implement the solutions and create another updated version of the game in the future.

##  <a name="SSLT"></a>Semi-smooth Level Transitions
In my game, upon completing a level, the screen is refilled with the background colour and then the map is redrawn. There is a simple (albeit memory-sacraficing) solution to a smooth level transition.

The solution is as follows:
1. In the `.data` section, reserve the same about of space required for your game screen. To make this explanation easier to follow, we will name it "next_screen"

2. There are two options, either prepare the next screen at the start of the level or at the end.

3. From here you have several transition options, I will only list one.
    - To do a transition where the current level slides upwards and the next scene follows below:
        - Store the current y-level in a temporary register. In the viewable screen, starting at the second row, shift all pixels up one row. At the bottom row, copy the pixels in "next_screen" at the *y-level* row. Increment y-level until you reach the last row of your display.

<p align="center">Since this is simple enough to implement, below is a proof-of-concept:</p>
<p align="center">
    <img src="https://i.gyazo.com/fe5d8c6d8bb6b0e813fad5750279b641.gif" alt="Semi-smooth level transition Demonstration">
</p>

To draw the player at the levels spawn position, this way, the player will appear to have already been in the next level prior to the transition.

## Better Collision/Rendering
My collision method only allows platform tiles of a single color and consider "background" as one color, simplifying the implementation and preventing stuttering during rerendering. While this approach is simple, it may limit the visual appeal of the game if multicolored tiles are desired. I had the thought of making the levels more visually appealing while keeping stutters at a minimum, however, I did not implement it. Anyways, here is the potential solution that I came up with, note that depending on the size of your framebuffer, it could take up a massive portion of your available space in `.data`.

Reserve the same amount of space required for your game screen. If you plan on making platform tiles multi-colored, you would need to reserve another array to hold the positions of the platforms (unless of course, you implement the collision system better.) The second array stores `0x0` values, you can just paint the sections that are supposed to be the platforms, as long as it is not `0x0`.

The first array will hold a copy of the game screen (no entities or anything, just the background)
The second array will hold the platform tile positions.

On start of the level, draw the first array onto the game screen and also place the player and other objects onto the screen. To clear where an object (such as the player) last was:
- For each positions that the character takes up on the screen, copy the pixels of the first array located at that same position and draw it onto its position on the game screen.
- To check for collisions, simply find the required collision points on the player and look at that position in your second array. If the value stored in the second array is not `0x0`, then we are on a platform.
